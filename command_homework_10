-- Оптимизация запросов
-- 1. Проанализировать какие запросы могут выполняться наиболее часто в процессе работы приложения и добавить необходимые индексы.
-- Наиболее часто из типов запросов могут использоваться:
	-- команды, работающие со структурой базы данных: create
	-- команды работающие с данными: select, update,delete, insert
CREATE INDEX users_last_name_idx ON users(last_name);
CREATE INDEX messages_from_user_id_idx ON messages(from_user_id);
-- 2. Вариант с вложенными запросами в части SELECT
select
	distinct communities.name as group_name,
	COUNT(communities_users.user_id) over() / (
	select
		COUNT(*)
	from
		communities) as avg_users_in_groups,
	first_value(CONCAT_WS(" ", users.first_name, users.last_name)) over (w_community
order by
	profiles.birthday desc) as youngest,
	first_value(CONCAT_WS(" ", users.first_name, users.last_name)) over (w_community
order by
	profiles.birthday asc) as oldest,
	COUNT(communities_users.user_id) over w_community as users_in_group,
	(
	select
		COUNT(*)
	from
		users) as users_total,
	COUNT(communities_users.user_id) over w_community / (
	select
		COUNT(*)
	from
		users) * 100 as '%%'
from
	communities
left join communities_users on
	communities_users.community_id = communities.id
left join users on
	communities_users.user_id = users.id
left join profiles on
	profiles.user_id = users.id window w_community as (partition by communities.id);
                              
-- Вариант с вложенными запросами в объединении JOIN
select
	distinct communities.name as group_name,
	COUNT(communities_users.user_id) over() / total_communities as avg_users_in_groups,
	first_value(CONCAT_WS(" ", users.first_name, users.last_name)) over (w_community
order by
	profiles.birthday desc) as youngest,
	first_value(CONCAT_WS(" ", users.first_name, users.last_name)) over (w_community
order by
	profiles.birthday asc) as oldest,
	COUNT(communities_users.user_id) over w_community as users_in_group,
	total_users,
	COUNT(communities_users.user_id) over w_community / total_users * 100 as '%%'
from
	(
	select
		COUNT(*) as total_users
	from
		users) as tu
cross join (
	select
		COUNT(*) as total_communities
	from
		communities) as tc
cross join communities
left join communities_users on
	communities_users.community_id = communities.id
left join users on
	communities_users.user_id = users.id
left join profiles on
	profiles.user_id = users.id window w_community as (partition by communities.id);
